# 前端实验报告：核心代码附录（精简版）

> 本文件只包含“代码展示 + 职责说明”，用于粘贴回你的报告正文中；不会改动正文内容。

## A1 依赖与脚本（package.json 摘要）

职责：说明前端采用的核心技术栈与关键依赖，作为技术选型依据。

```json
{
  "scripts": {
    "dev": "vite",
    "build:prod": "vite build"
  },
  "dependencies": {
    "vue": "3.2.45",
    "vue-router": "4.1.4",
    "pinia": "2.0.22",
    "element-plus": "2.2.27",
    "axios": "0.27.2",
    "nprogress": "0.2.0",
    "vue-plugin-hiprint": "^0.0.56"
  }
}
```

## A2 主题 Token + 玻璃拟态（theme.css / modern-ui.scss 摘要）

职责：统一页面颜色/字体语义，并为卡片/容器提供玻璃拟态视觉效果，保证全站风格一致。

```css
:root {
  --el-font-family: "Helvetica Neue", "Microsoft YaHei", Arial, sans-serif;
  --color-primary: #324157;
  --bg-page: #f0f2f5;
  --text-primary: #303133;
  --el-color-primary: var(--color-primary);
  --el-bg-color-page: var(--bg-page);
  --el-text-color-primary: var(--text-primary);
}
```

```scss
.glass-effect {
  background: rgba(255, 255, 255, 0.7) !important;
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.el-card {
  border-radius: 16px !important;
  background: rgba(255, 255, 255, 0.8) !important;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05) !important;
}
```

## A3 请求封装（request.js 核心：token + 重复提交 + 统一错误）

职责：所有接口统一走这一层：自动携带 token、拦截重复提交、统一错误提示与 401 过期处理。

```js
import axios from 'axios'
import { ElMessageBox, ElMessage } from 'element-plus'
import { getToken } from '@/utils/auth'
import cache from '@/plugins/cache'
import useUserStore from '@/store/modules/user'

export let isRelogin = { show: false }

const service = axios.create({
  baseURL: import.meta.env.VITE_APP_BASE_API,
  timeout: 10000
})

service.interceptors.request.use(config => {
  const isToken = (config.headers || {}).isToken === false
  const isRepeatSubmit = (config.headers || {}).repeatSubmit === false

  if (getToken() && !isToken) config.headers['Authorization'] = 'Bearer ' + getToken()

  if (!isRepeatSubmit && (config.method === 'post' || config.method === 'put')) {
    const requestObj = { url: config.url, data: JSON.stringify(config.data), time: Date.now() }
    const sessionObj = cache.session.getJSON('sessionObj')
    if (sessionObj && sessionObj.url === requestObj.url && sessionObj.data === requestObj.data && requestObj.time - sessionObj.time < 1000) {
      return Promise.reject(new Error('数据正在处理，请勿重复提交'))
    }
    cache.session.setJSON('sessionObj', requestObj)
  }

  return config
})

service.interceptors.response.use(res => {
  const code = res.data.code || 200
  if (code === 401) {
    if (!isRelogin.show) {
      isRelogin.show = true
      ElMessageBox.confirm('登录状态已过期，是否重新登录？', '系统提示').then(() => {
        isRelogin.show = false
        useUserStore().logOut().then(() => {
          window.location.href = import.meta.env.VITE_APP_CONTEXT_PATH + 'login'
        })
      }).catch(() => { isRelogin.show = false })
    }
    return Promise.reject(new Error('无效会话'))
  }
  if (code === 409) return Promise.reject(new Error(res.data.detailMessage || '业务冲突'))
  if (code !== 200) return Promise.reject(new Error(res.data.msg || '请求失败'))
  return res.data
}, err => {
  ElMessage.error(err.message || '系统接口异常')
  return Promise.reject(err)
})

export default service
```

## A4 权限守卫（permission.js 核心流程）

职责：统一控制页面访问权限：无 token 重定向登录；首次进入拉取 user_info 并动态 addRoute 挂载菜单路由。

```js
import router from './router'
import NProgress from 'nprogress'
import { getToken } from '@/utils/auth'
import { isHttp } from '@/utils/validate'
import { isRelogin } from '@/utils/request'
import useUserStore from '@/store/modules/user'
import usePermissionStore from '@/store/modules/permission'
import { useWmsStore } from '@/store/modules/wms'

const whiteList = ['/login', '/register']

router.beforeEach((to, from, next) => {
  NProgress.start()

  if (!getToken()) {
    if (whiteList.includes(to.path)) next()
    else next(`/login?redirect=${to.fullPath}`)
    NProgress.done()
    return
  }

  if (to.path === '/login') {
    next({ path: '/' })
    NProgress.done()
    return
  }

  if (useUserStore().roles.length === 0) {
    isRelogin.show = true
    useUserStore().getInfo().then(() => {
      isRelogin.show = false
      usePermissionStore().generateRoutes().then(accessRoutes => {
        accessRoutes.forEach(route => {
          if (!isHttp(route.path)) router.addRoute(route)
        })
        next({ ...to, replace: true })
      })
    })
    initWmsBaseData()
  } else {
    next()
  }
})

async function initWmsBaseData() {
  await useWmsStore().getWarehouseList()
  await useWmsStore().getMerchantList()
  await useWmsStore().getItemCategoryList()
  await useWmsStore().getItemBrandList()
}
```

## A5 路由结构（router/index.js 核心部分）

职责：提供静态路由与 Layout 容器；动态路由会在运行时按权限 addRoute 注入到 router 中。

```js
import { createWebHistory, createRouter } from 'vue-router'
import Layout from '@/layout'

export const constantRoutes = [
  { path: '/login', component: () => import('@/views/login'), hidden: true },
  { path: '/register', component: () => import('@/views/register'), hidden: true },
  { path: '/401', component: () => import('@/views/error/401'), hidden: true },
  { path: '/:pathMatch(.*)*', component: () => import('@/views/error/404'), hidden: true },
  {
    path: '',
    component: Layout,
    redirect: '/index',
    children: [
      { path: '/index', component: () => import('@/views/dashboard/charts'), name: 'Index', meta: { title: '首页' } }
    ]
  }
]

export default createRouter({
  history: createWebHistory(import.meta.env.VITE_APP_CONTEXT_PATH),
  routes: constantRoutes
})
```

## A6 登录页核心（login.vue：登录提交 + 眼睛跟随）

职责：登录逻辑（校验→登录→跳转）与性能友好的跟随动画（rAF 降频 + transform）。

```js
function handleLogin() {
  proxy.$refs.loginRef.validate(valid => {
    if (!valid) return
    loading.value = true
    userStore.login(loginForm.value).then(() => {
      router.push({ path: redirect.value || "/" })
    }).catch(() => {
      loading.value = false
      if (captchaEnabled.value) getCode()
    })
  })
}

const handleMouseMove = (event) => {
  lastMouseX.value = event.clientX
  lastMouseY.value = event.clientY
  if (animationFrameId.value) cancelAnimationFrame(animationFrameId.value)
  animationFrameId.value = requestAnimationFrame(() => updateEyes())
}

const updateEyes = () => {
  const pupils = [leftPupilRef.value, rightPupilRef.value]
  if (!pupils[0] || !pupils[1]) return
  const leftRect = pupils[0].getBoundingClientRect()
  const rightRect = pupils[1].getBoundingClientRect()
  updatePupil(pupils[0], leftRect, lastMouseX.value, lastMouseY.value)
  updatePupil(pupils[1], rightRect, lastMouseX.value, lastMouseY.value)
}

const updatePupil = (pupil, rect, targetX, targetY) => {
  const x = rect.left + rect.width / 2
  const y = rect.top + rect.height / 2
  const dx = targetX - x
  const dy = targetY - y
  const angle = Math.atan2(dy, dx)
  const dist = Math.min(8, Math.hypot(dx, dy) / 30)
  pupil.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px)`
}
```

## A7 入库列表核心（receipt/index.vue：查询归一化 + 明细按需加载）

职责：把“全部”条件归一化为 null，避免误过滤；明细展开时再请求，提升首屏速度。

```js
function getList() {
  loading.value = true
  const query = { ...queryParams.value }
  if (query.orderStatus === -2) query.orderStatus = null
  if (query.optType === -1) query.optType = null

  listReceiptOrder(query).then(response => {
    receiptOrderList.value = response.rows
    total.value = response.total
    expandedRowKeys.value = []
  }).finally(() => {
    loading.value = false
  })
}

function handleGoDetail(row) {
  const index = expandedRowKeys.value.indexOf(row.id)
  if (index !== -1) expandedRowKeys.value.splice(index, 1)
  else {
    expandedRowKeys.value.push(row.id)
    loadReceiptOrderDetail(row)
  }
}

function loadReceiptOrderDetail(row) {
  const index = receiptOrderList.value.findIndex(it => it.id === row.id)
  detailLoading.value[index] = true
  listByReceiptOrderId(row.id).then(res => {
    receiptOrderList.value[index].details = res.data || []
  }).finally(() => {
    detailLoading.value[index] = false
  })
}
```

## A8 入库打印核心（receipt/index.vue：数据映射 → 打印输出）

职责：将后端单据结构转换为打印模板输入字段，并调用打印插件输出。

```js
async function handlePrint(row) {
  const res = await getReceiptOrder(row.id)
  const receiptOrder = res.data

  const table = (receiptOrder.details || []).map(detail => ({
    itemName: detail.item.itemName,
    skuName: detail.itemSku.skuName,
    quantity: Number(detail.quantity).toFixed(0),
    amount: detail.amount
  }))

  const printData = {
    orderNo: receiptOrder.orderNo,
    totalQuantity: Number(receiptOrder.totalQuantity).toFixed(0),
    totalAmount: (receiptOrder.totalAmount || receiptOrder.totalAmount === 0) ? (receiptOrder.totalAmount + '元') : '',
    table
  }

  let printTemplate = new proxy.$hiprint.PrintTemplate({ template: receiptPanel })
  printTemplate.print(printData)
}
```

